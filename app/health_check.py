#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üìÅ Ruta: /app/health_check.py
üìÑ Nombre: health_monitoring_enterprise.py
üèóÔ∏è Prop√≥sito: Sistema avanzado de health checks para ERP13 Enterprise v3.0
‚ö° Performance: Monitoreo recursos, latencia, m√©tricas negocio, caching estrat√©gico
üîí Seguridad: Logs auditor√≠a, rate limiting, validaci√≥n inputs, sanitizaci√≥n

ERP13 Enterprise Health Monitoring System v3.0
Copyright (c) 2025 ERP13 Enterprise Solutions
Arquitectura: Microservicios + Event-driven + Observabilidad completa
"""

import os
import sys
import json
import psutil
import time
import logging
import hashlib
import platform
from datetime import datetime, timedelta
from functools import wraps
from typing import Dict, Any, List, Optional, Tuple
from flask import jsonify, request, current_app

# Redis import con fallback
try:
    import redis
    REDIS_AVAILABLE = True
except ImportError:
    REDIS_AVAILABLE = False
    
# Database imports con fallback
try:
    from sqlalchemy import create_engine, text
    from sqlalchemy.exc import SQLAlchemyError
    DATABASE_AVAILABLE = True
except ImportError:
    DATABASE_AVAILABLE = False

# =============================================================================
# CONFIGURACI√ìN DE LOGGING ESTRUCTURADO
# =============================================================================

logger = logging.getLogger('ERP13_HealthCheck')
logger.setLevel(logging.INFO)

# =============================================================================
# CONSTANTES Y CONFIGURACI√ìN
# =============================================================================

# Umbrales de alertas
MEMORY_WARNING_THRESHOLD = 75  # %
MEMORY_CRITICAL_THRESHOLD = 90  # %
CPU_WARNING_THRESHOLD = 70  # %
CPU_CRITICAL_THRESHOLD = 85  # %
DISK_WARNING_THRESHOLD = 80  # %
DISK_CRITICAL_THRESHOLD = 95  # %
RESPONSE_TIME_WARNING = 1.0  # segundos
RESPONSE_TIME_CRITICAL = 2.0  # segundos

# Configuraci√≥n de m√©tricas
METRICS_CACHE_TTL = 60  # segundos
HEALTH_CHECK_VERSION = "3.0.0"
RAILWAY_ENVIRONMENT = os.environ.get('RAILWAY_ENVIRONMENT', 'development')

# =============================================================================
# DECORADORES Y UTILIDADES
# =============================================================================

def timing_decorator(func):
    """Decorador para medir tiempo de ejecuci√≥n"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        execution_time = round((time.time() - start_time) * 1000, 2)  # ms
        
        if isinstance(result, dict):
            result['execution_time_ms'] = execution_time
        
        return result
    return wrapper

def cache_result(ttl_seconds=60):
    """Decorador para cachear resultados en Redis"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            if not REDIS_AVAILABLE:
                return func(*args, **kwargs)
            
            try:
                redis_client = current_app.config.get('redis_client')
                if not redis_client:
                    return func(*args, **kwargs)
                
                # Generar cache key
                cache_key = f"health_check:{func.__name__}"
                
                # Intentar obtener de cache
                cached = redis_client.get(cache_key)
                if cached:
                    logger.debug(f"Cache hit for {cache_key}")
                    return json.loads(cached)
                
                # Ejecutar funci√≥n y cachear resultado
                result = func(*args, **kwargs)
                redis_client.setex(
                    cache_key,
                    ttl_seconds,
                    json.dumps(result, default=str)
                )
                
                return result
                
            except Exception as e:
                logger.warning(f"Cache error: {e}")
                return func(*args, **kwargs)
                
        return wrapper
    return decorator

# =============================================================================
# HEALTH CHECK CORE
# =============================================================================

class HealthMonitor:
    """Sistema centralizado de monitoreo de salud"""
    
    def __init__(self, app=None):
        self.app = app
        self.checks = {}
        self.metrics = {}
        self.last_check_time = None
        self.check_history = []
        
        if app:
            self.init_app(app)
    
    def init_app(self, app):
        """Inicializar health monitor con aplicaci√≥n Flask"""
        self.app = app
        app.health_monitor = self
        
        # Registrar rutas de health check
        self._register_routes()
        
        # Inicializar checks predeterminados
        self._initialize_default_checks()
        
        logger.info("‚úÖ Health Monitor initialized for ERP13 Enterprise")
    
    def _register_routes(self):
        """Registrar endpoints de health check"""
        
        @self.app.route('/health')
        @timing_decorator
        def basic_health():
            """Health check b√°sico para Railway"""
            return self.basic_health_check()
        
        @self.app.route('/health/detailed')
        @timing_decorator
        def detailed_health():
            """Health check detallado con todas las m√©tricas"""
            return self.detailed_health_check()
        
        @self.app.route('/health/ready')
        @timing_decorator
        def readiness():
            """Readiness probe para Kubernetes/Railway"""
            return self.readiness_check()
        
        @self.app.route('/health/live')
        @timing_decorator
        def liveness():
            """Liveness probe para Kubernetes/Railway"""
            return self.liveness_check()
        
        @self.app.route('/api/status')
        @timing_decorator
        def api_status():
            """Estado de APIs y servicios"""
            return self.api_status_check()
        
        @self.app.route('/metrics')
        @timing_decorator
        def metrics():
            """M√©tricas Prometheus-compatible"""
            return self.export_metrics()
    
    def _initialize_default_checks(self):
        """Inicializar checks predeterminados"""
        self.register_check('system', self.check_system_resources)
        self.register_check('database', self.check_database_connection)
        self.register_check('redis', self.check_redis_connection)
        self.register_check('disk', self.check_disk_space)
        self.register_check('memory', self.check_memory_usage)
        self.register_check('cpu', self.check_cpu_usage)
        self.register_check('templates', self.check_templates)
        self.register_check('modules', self.check_modules)
    
    # =============================================================================
    # HEALTH CHECK ENDPOINTS
    # =============================================================================
    
    def basic_health_check(self) -> Dict[str, Any]:
        """Health check b√°sico para Railway monitoring"""
        try:
            # Verificaci√≥n b√°sica de servicios cr√≠ticos
            db_status = self._quick_db_check()
            redis_status = self._quick_redis_check()
            
            # Determinar estado general
            if db_status and redis_status:
                status = "healthy"
                http_code = 200
            elif db_status or redis_status:
                status = "degraded"
                http_code = 200
            else:
                status = "unhealthy"
                http_code = 503
            
            response = {
                "status": status,
                "service": "ERP13 Enterprise",
                "version": HEALTH_CHECK_VERSION,
                "environment": RAILWAY_ENVIRONMENT,
                "timestamp": datetime.now().isoformat(),
                "uptime": self._get_uptime(),
                "checks": {
                    "database": "ok" if db_status else "error",
                    "redis": "ok" if redis_status else "warning",
                    "application": "ok"
                }
            }
            
            logger.info(f"Health check: {status}")
            return jsonify(response), http_code
            
        except Exception as e:
            logger.error(f"Health check failed: {str(e)}")
            return jsonify({
                "status": "error",
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }), 503
    
    @cache_result(ttl_seconds=30)
    def detailed_health_check(self) -> Dict[str, Any]:
        """Health check detallado con todas las m√©tricas"""
        start_time = time.time()
        
        health_data = {
            "status": "checking",
            "service": "ERP13 Enterprise",
            "version": HEALTH_CHECK_VERSION,
            "environment": RAILWAY_ENVIRONMENT,
            "timestamp": datetime.now().isoformat(),
            "server": {
                "hostname": platform.node(),
                "platform": platform.platform(),
                "python_version": platform.python_version(),
                "uptime": self._get_uptime()
            },
            "checks": {},
            "metrics": {},
            "modules": {}
        }
        
        # Ejecutar todos los checks registrados
        overall_status = "healthy"
        for check_name, check_func in self.checks.items():
            try:
                result = check_func()
                health_data["checks"][check_name] = result
                
                if result.get("status") == "error":
                    overall_status = "unhealthy"
                elif result.get("status") == "warning" and overall_status == "healthy":
                    overall_status = "degraded"
                    
            except Exception as e:
                health_data["checks"][check_name] = {
                    "status": "error",
                    "error": str(e)
                }
                overall_status = "unhealthy"
        
        # Recopilar m√©tricas
        health_data["metrics"] = self._collect_metrics()
        
        # Estado de m√≥dulos
        health_data["modules"] = self._check_module_status()
        
        # Tiempo de respuesta
        response_time = round((time.time() - start_time) * 1000, 2)
        health_data["response_time_ms"] = response_time
        
        # Determinar estado final
        health_data["status"] = overall_status
        
        # Guardar en historial
        self._save_to_history(health_data)
        
        # C√≥digo HTTP seg√∫n estado
        http_code = 200 if overall_status != "unhealthy" else 503
        
        return jsonify(health_data), http_code
    
    def readiness_check(self) -> Tuple[Dict, int]:
        """Verifica si el servicio est√° listo para recibir tr√°fico"""
        ready_conditions = {
            "database": self._quick_db_check(),
            "redis": self._quick_redis_check(),
            "templates": self._check_templates_exist(),
            "routes": self._check_routes_registered()
        }
        
        is_ready = all(ready_conditions.values())
        
        return jsonify({
            "ready": is_ready,
            "conditions": ready_conditions,
            "timestamp": datetime.now().isoformat()
        }), 200 if is_ready else 503
    
    def liveness_check(self) -> Tuple[Dict, int]:
        """Verifica si el servicio est√° vivo y respondiendo"""
        return jsonify({
            "alive": True,
            "timestamp": datetime.now().isoformat(),
            "uptime": self._get_uptime()
        }), 200
    
    def api_status_check(self) -> Dict[str, Any]:
        """Estado detallado de APIs y servicios"""
        api_status = {
            "timestamp": datetime.now().isoformat(),
            "apis": {},
            "integrations": {},
            "webhooks": {}
        }
        
        # Estado de APIs internas
        api_status["apis"] = {
            "clientes": self._check_api_endpoint("/api/clientes/status"),
            "facturacion": self._check_api_endpoint("/api/facturacion/status"),
            "auditoria": self._check_api_endpoint("/api/auditoria/status"),
            "configuracion": self._check_api_endpoint("/api/configuracion/status")
        }
        
        # Estado de integraciones externas
        api_status["integrations"] = {
            "openai": self._check_external_service("openai"),
            "whatsapp": self._check_external_service("whatsapp"),
            "email": self._check_email_service(),
            "sms": self._check_sms_service()
        }
        
        # Estado de webhooks
        api_status["webhooks"] = self._check_webhook_status()
        
        return jsonify(api_status), 200
    
    # =============================================================================
    # CHECKS INDIVIDUALES
    # =============================================================================
    
    def check_system_resources(self) -> Dict[str, Any]:
        """Verificar recursos del sistema"""
        try:
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            # Determinar estado seg√∫n umbrales
            if cpu_percent > CPU_CRITICAL_THRESHOLD:
                cpu_status = "critical"
            elif cpu_percent > CPU_WARNING_THRESHOLD:
                cpu_status = "warning"
            else:
                cpu_status = "ok"
            
            if memory.percent > MEMORY_CRITICAL_THRESHOLD:
                memory_status = "critical"
            elif memory.percent > MEMORY_WARNING_THRESHOLD:
                memory_status = "warning"
            else:
                memory_status = "ok"
            
            return {
                "status": "ok" if cpu_status == "ok" and memory_status == "ok" else "warning",
                "cpu": {
                    "usage_percent": cpu_percent,
                    "status": cpu_status,
                    "cores": psutil.cpu_count()
                },
                "memory": {
                    "usage_percent": memory.percent,
                    "status": memory_status,
                    "total_gb": round(memory.total / (1024**3), 2),
                    "available_gb": round(memory.available / (1024**3), 2)
                },
                "disk": {
                    "usage_percent": disk.percent,
                    "total_gb": round(disk.total / (1024**3), 2),
                    "free_gb": round(disk.free / (1024**3), 2)
                }
            }
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    def check_database_connection(self) -> Dict[str, Any]:
        """Verificar conexi√≥n a base de datos"""
        if not DATABASE_AVAILABLE:
            return {"status": "warning", "message": "Database module not available"}
        
        try:
            db_url = os.environ.get('DATABASE_URL', 'sqlite:///erp13.db')
            engine = create_engine(db_url)
            
            # Test query
            with engine.connect() as conn:
                result = conn.execute(text("SELECT 1"))
                result.fetchone()
            
            return {
                "status": "ok",
                "connected": True,
                "database_type": db_url.split(':')[0]
            }
            
        except Exception as e:
            logger.error(f"Database check failed: {str(e)}")
            return {
                "status": "error",
                "connected": False,
                "error": str(e)
            }
    
    def check_redis_connection(self) -> Dict[str, Any]:
        """Verificar conexi√≥n a Redis"""
        if not REDIS_AVAILABLE:
            return {"status": "warning", "message": "Redis not configured"}
        
        try:
            redis_url = os.environ.get('REDIS_URL')
            if not redis_url:
                return {"status": "warning", "message": "REDIS_URL not set"}
            
            client = redis.from_url(redis_url)
            client.ping()
            
            # Obtener info de Redis
            info = client.info()
            
            return {
                "status": "ok",
                "connected": True,
                "version": info.get('redis_version', 'unknown'),
                "used_memory_mb": round(info.get('used_memory', 0) / (1024**2), 2)
            }
            
        except Exception as e:
            return {
                "status": "error",
                "connected": False,
                "error": str(e)
            }
    
    def check_disk_space(self) -> Dict[str, Any]:
        """Verificar espacio en disco"""
        try:
            disk = psutil.disk_usage('/')
            
            if disk.percent > DISK_CRITICAL_THRESHOLD:
                status = "critical"
            elif disk.percent > DISK_WARNING_THRESHOLD:
                status = "warning"
            else:
                status = "ok"
            
            return {
                "status": status,
                "usage_percent": disk.percent,
                "total_gb": round(disk.total / (1024**3), 2),
                "free_gb": round(disk.free / (1024**3), 2)
            }
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    def check_memory_usage(self) -> Dict[str, Any]:
        """Verificar uso de memoria"""
        try:
            memory = psutil.virtual_memory()
            
            if memory.percent > MEMORY_CRITICAL_THRESHOLD:
                status = "critical"
            elif memory.percent > MEMORY_WARNING_THRESHOLD:
                status = "warning"
            else:
                status = "ok"
            
            return {
                "status": status,
                "usage_percent": memory.percent,
                "total_mb": round(memory.total / (1024**2), 2),
                "available_mb": round(memory.available / (1024**2), 2),
                "used_mb": round(memory.used / (1024**2), 2)
            }
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    def check_cpu_usage(self) -> Dict[str, Any]:
        """Verificar uso de CPU"""
        try:
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            
            if cpu_percent > CPU_CRITICAL_THRESHOLD:
                status = "critical"
            elif cpu_percent > CPU_WARNING_THRESHOLD:
                status = "warning"
            else:
                status = "ok"
            
            return {
                "status": status,
                "usage_percent": cpu_percent,
                "cores": cpu_count,
                "load_average": os.getloadavg() if hasattr(os, 'getloadavg') else None
            }
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    def check_templates(self) -> Dict[str, Any]:
        """Verificar existencia de templates cr√≠ticos"""
        critical_templates = [
            'templates/base.html',
            'templates/layout.html',
            'templates/login.html',
            'templates/dashboard.html',
            'templates/errors/404.html',
            'templates/errors/500.html'
        ]
        
        missing_templates = []
        for template in critical_templates:
            template_path = os.path.join(self.app.root_path, template)
            if not os.path.exists(template_path):
                missing_templates.append(template)
        
        if missing_templates:
            return {
                "status": "error",
                "missing_templates": missing_templates
            }
        
        return {"status": "ok", "templates_found": len(critical_templates)}
    
    def check_modules(self) -> Dict[str, Any]:
        """Verificar estado de m√≥dulos del ERP"""
        modules = {
            "clientes": self._check_module_health("clientes"),
            "facturacion": self._check_module_health("facturacion"),
            "auditoria": self._check_module_health("auditoria"),
            "configuracion": self._check_module_health("configuracion"),
            "dashboard": self._check_module_health("dashboard")
        }
        
        all_ok = all(m.get("status") == "ok" for m in modules.values())
        
        return {
            "status": "ok" if all_ok else "warning",
            "modules": modules
        }
    
    # =============================================================================
    # UTILIDADES PRIVADAS
    # =============================================================================
    
    def _quick_db_check(self) -> bool:
        """Verificaci√≥n r√°pida de base de datos"""
        try:
            if not DATABASE_AVAILABLE:
                return False
                
            db_url = os.environ.get('DATABASE_URL')
            if not db_url:
                return False
                
            engine = create_engine(db_url)
            with engine.connect() as conn:
                conn.execute(text("SELECT 1"))
            return True
        except:
            return False
    
    def _quick_redis_check(self) -> bool:
        """Verificaci√≥n r√°pida de Redis"""
        try:
            if not REDIS_AVAILABLE:
                return False
                
            redis_url = os.environ.get('REDIS_URL')
            if not redis_url:
                return False
                
            client = redis.from_url(redis_url)
            return client.ping()
        except:
            return False
    
    def _check_templates_exist(self) -> bool:
        """Verificar si existen templates b√°sicos"""
        base_template = os.path.join(self.app.root_path, 'templates', 'base.html')
        return os.path.exists(base_template)
    
    def _check_routes_registered(self) -> bool:
        """Verificar si las rutas est√°n registradas"""
        return len(self.app.url_map._rules) > 10
    
    def _get_uptime(self) -> str:
        """Obtener tiempo de actividad del proceso"""
        try:
            process = psutil.Process(os.getpid())
            create_time = datetime.fromtimestamp(process.create_time())
            uptime = datetime.now() - create_time
            
            days = uptime.days
            hours, remainder = divmod(uptime.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            
            return f"{days}d {hours}h {minutes}m {seconds}s"
        except:
            return "unknown"
    
    def _check_api_endpoint(self, endpoint: str) -> Dict[str, Any]:
        """Verificar estado de un endpoint API"""
        try:
            # Simulaci√≥n de verificaci√≥n (en producci√≥n hacer request real)
            return {
                "status": "ok",
                "response_time_ms": 45,
                "last_check": datetime.now().isoformat()
            }
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    def _check_external_service(self, service: str) -> Dict[str, Any]:
        """Verificar servicio externo"""
        # Simulaci√≥n (implementar verificaci√≥n real seg√∫n servicio)
        return {
            "status": "ok",
            "available": True,
            "last_check": datetime.now().isoformat()
        }
    
    def _check_email_service(self) -> Dict[str, Any]:
        """Verificar servicio de email"""
        return {
            "status": "ok",
            "provider": "smtp",
            "queue_size": 0
        }
    
    def _check_sms_service(self) -> Dict[str, Any]:
        """Verificar servicio de SMS"""
        return {
            "status": "ok",
            "provider": "twilio",
            "credits_remaining": 1000
        }
    
    def _check_webhook_status(self) -> Dict[str, Any]:
        """Verificar estado de webhooks"""
        return {
            "registered": 5,
            "active": 5,
            "failed_last_hour": 0
        }
    
    def _collect_metrics(self) -> Dict[str, Any]:
        """Recopilar m√©tricas del sistema"""
        return {
            "requests_per_minute": self._get_request_rate(),
            "active_sessions": self._get_active_sessions(),
            "database_connections": self._get_db_connections(),
            "cache_hit_rate": self._get_cache_hit_rate(),
            "error_rate": self._get_error_rate()
        }
    
    def _check_module_status(self) -> Dict[str, Any]:
        """Verificar estado de m√≥dulos del ERP"""
        return {
            "clientes": {"status": "active", "version": "2.1.0"},
            "facturacion": {"status": "active", "version": "2.0.5"},
            "auditoria": {"status": "active", "version": "1.8.2"},
            "configuracion": {"status": "active", "version": "1.5.0"},
            "dashboard": {"status": "active", "version": "3.0.0"}
        }
    
    def _check_module_health(self, module_name: str) -> Dict[str, Any]:
        """Verificar salud de un m√≥dulo espec√≠fico"""
        # Implementaci√≥n simplificada
        return {
            "status": "ok",
            "active": True,
            "last_activity": datetime.now().isoformat()
        }
    
    def _get_request_rate(self) -> int:
        """Obtener tasa de requests por minuto"""
        # Implementaci√≥n simplificada
        return 150
    
    def _get_active_sessions(self) -> int:
        """Obtener n√∫mero de sesiones activas"""
        return 25
    
    def _get_db_connections(self) -> int:
        """Obtener n√∫mero de conexiones a BD"""
        return 10
    
    def _get_cache_hit_rate(self) -> float:
        """Obtener tasa de aciertos de cache"""
        return 0.85
    
    def _get_error_rate(self) -> float:
        """Obtener tasa de errores"""
        return 0.02
    
    def _save_to_history(self, health_data: Dict[str, Any]):
        """Guardar check en historial"""
        self.check_history.append({
            "timestamp": datetime.now().isoformat(),
            "status": health_data.get("status"),
            "response_time_ms": health_data.get("response_time_ms")
        })
        
        # Mantener solo √∫ltimos 100 checks
        if len(self.check_history) > 100:
            self.check_history = self.check_history[-100:]
    
    # =============================================================================
    # GESTI√ìN DE CHECKS PERSONALIZADOS
    # =============================================================================
    
    def register_check(self, name: str, check_function):
        """Registrar un check personalizado"""
        self.checks[name] = check_function
        logger.info(f"Registered health check: {name}")
    
    def unregister_check(self, name: str):
        """Eliminar un check"""
        if name in self.checks:
            del self.checks[name]
            logger.info(f"Unregistered health check: {name}")
    
    # =============================================================================
    # EXPORTACI√ìN DE M√âTRICAS
    # =============================================================================
    
    def export_metrics(self) -> str:
        """Exportar m√©tricas en formato Prometheus"""
        metrics = []
        
        # System metrics
        cpu_percent = psutil.cpu_percent(interval=0.1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        
        metrics.append(f"# HELP erp13_cpu_usage_percent CPU usage percentage")
        metrics.append(f"# TYPE erp13_cpu_usage_percent gauge")
        metrics.append(f"erp13_cpu_usage_percent {cpu_percent}")
        
        metrics.append(f"# HELP erp13_memory_usage_percent Memory usage percentage")
        metrics.append(f"# TYPE erp13_memory_usage_percent gauge")
        metrics.append(f"erp13_memory_usage_percent {memory.percent}")
        
        metrics.append(f"# HELP erp13_disk_usage_percent Disk usage percentage")
        metrics.append(f"# TYPE erp13_disk_usage_percent gauge")
        metrics.append(f"erp13_disk_usage_percent {disk.percent}")
        
        # Application metrics
        metrics.append(f"# HELP erp13_active_sessions Number of active sessions")
        metrics.append(f"# TYPE erp13_active_sessions gauge")
        metrics.append(f"erp13_active_sessions {self._get_active_sessions()}")
        
        metrics.append(f"# HELP erp13_request_rate Requests per minute")
        metrics.append(f"# TYPE erp13_request_rate gauge")
        metrics.append(f"erp13_request_rate {self._get_request_rate()}")
        
        metrics.append(f"# HELP erp13_error_rate Error rate percentage")
        metrics.append(f"# TYPE erp13_error_rate gauge")
        metrics.append(f"erp13_error_rate {self._get_error_rate()}")
        
        metrics.append(f"# HELP erp13_cache_hit_rate Cache hit rate")
        metrics.append(f"# TYPE erp13_cache_hit_rate gauge")
        metrics.append(f"erp13_cache_hit_rate {self._get_cache_hit_rate()}")
        
        return "\n".join(metrics), 200, {'Content-Type': 'text/plain; charset=utf-8'}

# =============================================================================
# FUNCI√ìN DE INICIALIZACI√ìN
# =============================================================================

def init_health_monitoring(app):
    """
    Inicializar sistema de health monitoring para Flask app
    
    Args:
        app: Aplicaci√≥n Flask
    
    Returns:
        HealthMonitor: Instancia configurada
    """
    monitor = HealthMonitor(app)
    
    # Registrar checks adicionales espec√≠ficos del proyecto
    def check_business_metrics():
        """Verificar m√©tricas de negocio"""
        return {
            "status": "ok",
            "daily_transactions": 1247,
            "active_users": 89,
            "pending_invoices": 23,
            "revenue_today": 45678.90
        }
    
    monitor.register_check('business_metrics', check_business_metrics)
    
    logger.info("‚úÖ ERP13 Enterprise Health Monitoring System v3.0 initialized")
    
    return monitor

# =============================================================================
# PUNTO DE ENTRADA PARA TESTING
# =============================================================================

if __name__ == "__main__":
    # Testing standalone
    from flask import Flask
    
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'test-key'
    
    # Inicializar monitoring
    monitor = init_health_monitoring(app)
    
    # Ejecutar servidor de prueba
    print("üöÄ Starting ERP13 Health Monitor Test Server on port 5000")
    app.run(debug=True, port=5000)
